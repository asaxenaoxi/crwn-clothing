Chapter 67:
1. Till now we had made single page without any ability to route to different pages. These are not real pages but it helps react SPAs
to behave and act just like normal webpages. For this we need to import "BrowserRouter" from react-router-dom in the index.js file
where the app is initialized and then we wrap this around the <App /> component like this <BrowserRouter><App/></BrowserRouter>.

2. Once you have wrapped this around, it provides the SPA ability to call upon route and links to navigate. To do this you need to
import "Route, Link, Switch" from react-router-dom. Route basically taks 3 arguments : exact, path, component. We replace simple
embeding to component <XYZ></XYZ> to <Route exact path="/XYZ" component={XYZ}></Route>. This creates a path for the component.

3. Now to link between these components you can use <Link/> and reference any of these paths or you could use the history.push property
to navigate by changing it dynamically anywhere in the code which can be more powerful than the <Link/> component.

4. The way the Route component wraps the main component is that it provides the calling component with properties match, history, location
where various values are present to help you manage.

Chapter 68:
1. We learned to superpower our components to access history, location and match properties using withRouter() from react-router-dom
To do this, we include this in the component where we need access to these properties and after importing, all you need to do is
while exporting the component we wrap the component in withRouter(MenuItem) [MenuItem is example of the component we are supercharging]
and thats it, now going to the MenuItem component, we will have access to these props inside of the props variable of that component along
with all the other properties being passed through react

2. Once we had access to these properties, we wanted to create an onClick action on the MenuItem for hats where it would goto that page.
To do this we in the div created a onClick function which basically uses props.history.push() to change the address location and in that
we want to dynamically use the component link url, so we pick what url matched to the current page (props.match.url) and append the url
of where we want to go and that is being passed down in props by the directory as it was defined in the selections array as one of the 
attributes called linkUrl.

3. We also learned the use of "..."<variableName> shortcut to pass attributes of one object down to the components implicitly without 
naming every property of the component equalling the attribute of the object when the attribute name and property name is same. Only 
exception is "id" attribute which is named key in the component properties, hence we deconstruct the "selection" object as 
{id, ...otherSectionProps} 

Chapter 70:
1. Whenever you create a component where there is a state and requirement of data etc, its best to create a class rather than a functional
component. You need to call constructor with props to ensure its available and can be passed to super and then you initialize state of this
component by creating an object of objects / arrays or single primitive values or a combination.

class ShopPage extends React.Component 
{
    constructor(props) 
    {
        super(props);

        this.state = {
            collections: SHOP_DATASTORE
        }
    }

    render() {
        return( ... HTML & JS ... )
    }
}

VS

Arrow function with props as a parameter
const ShopPage = (props) => (
... HTML & JS ...
)

2. If you have a large object / array and you do not want to over crowd your own main object, you can put it in its own js file and import
the object and equalize it within the state.

3. .filter & .map return arrays themselves. Both are taking a function with return of either each single item or item and index and then 
return of that function for each item is based on the condition, so in case .filter((item, index) => (index < 4)) will return item only 
when index is less than 4 only, after that it will ignore and no more items will be put into the return array.

Chapter 71:
1. Adding dynamic styles to div as follows
<div className='background-image' style={{backgroundImage: `url(${props.imageUrl})`}}></div>

Ref: https://www.w3schools.com/react/react_css.asp
style is a css property which accepts objects as value. The first {} is to specify that its javascript and then next {} specify that its an object 
with key:value pairs inside of it, eg backgroundImage: <value>. Also backgrounImage is a js property not css and hence is in camel case and since 
that entire thing is a js object, the value side which needs another variable (imageUrl) needs to be put in ticks which evaluate the dynamic part 
of the string and puts all of it in a concatinated form as value. the reason you need ${} is because you need to tell js that while this is a 
string value but its got something that needs to be evaluated from javascript so anything with ${} needs to be expanded from js variable to string
